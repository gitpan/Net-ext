The following patch should be applied in the perl5.001 source directory.
Use ``patch -p0 -N''.  This avoids core dumps and bogus failures caused
by problems perl has in maintaining the 'pad' for lexical variables.

*** scope.c.~1~	Tue Jan 17 15:50:19 1995
--- scope.c	Mon Apr  3 00:52:55 1995
***************
*** 276,282 ****
  IV *ivp;
  {
      SSCHECK(3);
!     SSPUSHINT(*ivp);
      SSPUSHPTR(ivp);
      SSPUSHINT(SAVEt_IV);
  }
--- 276,282 ----
  IV *ivp;
  {
      SSCHECK(3);
!     SSPUSHIV(*ivp);
      SSPUSHPTR(ivp);
      SSPUSHINT(SAVEt_IV);
  }
***************
*** 365,371 ****
  SV** svp;
  {
      SSCHECK(2);
!     SSPUSHPTR(svp);
      SSPUSHINT(SAVEt_CLEARSV);
  }
  
--- 365,371 ----
  SV** svp;
  {
      SSCHECK(2);
!     SSPUSHLONG((long)(svp-curpad));
      SSPUSHINT(SAVEt_CLEARSV);
  }
  
***************
*** 540,546 ****
  	    Safefree((char*)ptr);
  	    break;
  	case SAVEt_CLEARSV:
! 	    ptr = SSPOPPTR;
  	    sv = *(SV**)ptr;
  	    if (SvREFCNT(sv) <= 1) { /* Can clear pad variable in place. */
  		if (SvTHINKFIRST(sv)) {
--- 540,546 ----
  	    Safefree((char*)ptr);
  	    break;
  	case SAVEt_CLEARSV:
! 	    ptr = (void*)&curpad[SSPOPLONG];
  	    sv = *(SV**)ptr;
  	    if (SvREFCNT(sv) <= 1) { /* Can clear pad variable in place. */
  		if (SvTHINKFIRST(sv)) {
***************
*** 573,578 ****
--- 573,579 ----
  		}
  	    }
  	    else {	/* Someone has a claim on this, so abandon it. */
+ 		U32 padflags = SvFLAGS(sv) & (SVs_PADBUSY|SVs_PADMY|SVs_PADTMP);
  		SvREFCNT_dec(sv);	/* Cast current value to the winds. */
  		switch (SvTYPE(sv)) {	/* Console ourselves with a new value */
  		case SVt_PVAV:	*(SV**)ptr = (SV*)newAV();	break;
***************
*** 579,584 ****
--- 580,586 ----
  		case SVt_PVHV:	*(SV**)ptr = (SV*)newHV();	break;
  		default:	*(SV**)ptr = NEWSV(0,0);	break;
  		}
+ 		SvFLAGS(*(SV**)ptr) |= padflags; /* preserve pad nature */
  	    }
  	    break;
  	case SAVEt_DELETE:
*** op.c.~2~	Thu Mar 30 22:45:05 1995
--- op.c	Mon Apr  3 00:18:41 1995
***************
*** 2632,2638 ****
  	SAVESPTR(curpad);
  	curpad = 0;
  
! 	if (!SvFLAGS(cv) & SVpcv_CLONED)
  	    op_free(CvROOT(cv));
  	CvROOT(cv) = Nullop;
  	if (CvPADLIST(cv)) {
--- 2632,2638 ----
  	SAVESPTR(curpad);
  	curpad = 0;
  
! 	if (!(SvFLAGS(cv) & SVpcv_CLONED))
  	    op_free(CvROOT(cv));
  	CvROOT(cv) = Nullop;
  	if (CvPADLIST(cv)) {
***************
*** 2766,2771 ****
--- 2766,2772 ----
  	CvOUTSIDE(cv) = CvOUTSIDE(compcv);
  	CvOUTSIDE(compcv) = 0;
  	CvPADLIST(cv) = CvPADLIST(compcv);
+ 	CvPADLIST(compcv) = 0;
  	SvREFCNT_dec(compcv);
      }
      else {
*** pp_hot.c.~1~	Thu Mar 16 14:38:23 1995
--- pp_hot.c	Mon Apr  3 00:18:38 1995
***************
*** 1687,1693 ****
  	    if (CvDEPTH(cv) > AvFILL(padlist)) {
  		AV *av;
  		AV *newpad = newAV();
! 		AV *oldpad = (AV*)AvARRAY(svp[CvDEPTH(cv)-1]);
  		I32 ix = AvFILL((AV*)svp[1]);
  		svp = AvARRAY(svp[0]);
  		for ( ;ix > 0; ix--) {
--- 1687,1693 ----
  	    if (CvDEPTH(cv) > AvFILL(padlist)) {
  		AV *av;
  		AV *newpad = newAV();
! 		SV **oldpad = AvARRAY(svp[CvDEPTH(cv)-1]);
  		I32 ix = AvFILL((AV*)svp[1]);
  		svp = AvARRAY(svp[0]);
  		for ( ;ix > 0; ix--) {
***************
*** 1695,1701 ****
  			char *name = SvPVX(svp[ix]);
  			if (SvFLAGS(svp[ix]) & SVf_FAKE) { /* outer lexical? */
  			    av_store(newpad, ix,
! 				SvREFCNT_inc(AvARRAY(oldpad)[ix]) );
  			}
  			else {				/* our own lexical */
  			    if (*name == '@')
--- 1695,1701 ----
  			char *name = SvPVX(svp[ix]);
  			if (SvFLAGS(svp[ix]) & SVf_FAKE) { /* outer lexical? */
  			    av_store(newpad, ix,
! 				SvREFCNT_inc(oldpad[ix]) );
  			}
  			else {				/* our own lexical */
  			    if (*name == '@')
